# ============================================================================
# WARNING: This file is AUTO-GENERATED by build.py
# DO NOT EDIT THIS FILE MANUALLY!
#
# Any changes made to this file will be lost when build.py runs again.
# To make changes, edit the source files in the src/ directory instead.
#
# Generated from: db.py, schemas.py, models.py, main.py
# ============================================================================

# ===== All Imports =====
import hashlib
import os
import random
import time
from datetime import datetime
from typing import AsyncGenerator, Optional

import dotenv
import fastapi
from fastapi.middleware.cors import CORSMiddleware
from pydantic import AnyHttpUrl, BaseModel, Field
from sqlalchemy import DateTime, ForeignKey, Integer, String, func, select, update
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from sqlalchemy.orm import Mapped, declarative_base, mapped_column, relationship


# ===== From db.py =====
dotenv.load_dotenv()


db_url = os.getenv("DATABASE_URL")


if db_url is None:
    raise EnvironmentError("DATABASE_URL not set in environment variables")


Base = declarative_base()


async_engine = create_async_engine(db_url, echo=True, future=True)


async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_sessionmaker(
        bind=async_engine,
        expire_on_commit=False,
    )() as session:
        yield session


# ===== From schemas.py =====
class LinkCreate(BaseModel):
    long_url: AnyHttpUrl
    name: str | None = None


class LinkMetadataResponse(BaseModel):
    clicks: int
    last_ip: str | None
    custom_name: str | None = None


class LinkResponse(BaseModel):
    shortened_url: str
    long_url: AnyHttpUrl
    link_metadata: LinkMetadataResponse = Field(alias="metadata")


class ErrorResponse(BaseModel):
    error: str
    message: str
    redirect_to: str | None = None


class LinkRedirectResponse(BaseModel):
    message: str = "Redirecting to the original URL"
    redirect_to: str = Field(alias="long_url")


class LinkAliasAvailabilityResponse(BaseModel):
    alias: str
    is_available: bool


class LinkAliasSuggestionResponse(BaseModel):
    suggested_aliases: list[str]
    time_taken: float


class LinkURLExistenceResponse(BaseModel):
    long_url: AnyHttpUrl
    exists: bool


# ===== From models.py =====
class LinkMetadata(Base):
    __tablename__ = "link_metadata"

    link_id: Mapped[str] = mapped_column(
        ForeignKey("links.id"), primary_key=True, index=True
    )
    name: Mapped[str] = mapped_column(String, index=True)
    long_url: Mapped[str] = mapped_column(String)
    clicks: Mapped[int] = mapped_column(Integer, default=0)
    last_ip: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(
        DateTime, server_default=func.now(), onupdate=func.now()
    )

    link: Mapped["Link"] = relationship("Link", back_populates="link_metadata")


class LinkClickLog(Base):
    __tablename__ = "link_click_log"

    id: Mapped[int] = mapped_column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    link_id: Mapped[str] = mapped_column(ForeignKey("links.id"), index=True)
    click_ip: Mapped[Optional[str]] = mapped_column(String)
    timestamp: Mapped[Optional[datetime]] = mapped_column(DateTime)
    user_agent: Mapped[Optional[str]] = mapped_column(String)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())

    link: Mapped["Link"] = relationship("Link", back_populates="logs")


class Link(Base):
    __tablename__ = "links"

    id: Mapped[str] = mapped_column(String, primary_key=True, index=True)
    long_url: Mapped[str] = mapped_column(String, index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(
        DateTime, server_default=func.now(), onupdate=func.now()
    )

    link_metadata: Mapped["LinkMetadata"] = relationship(
        "LinkMetadata", back_populates="link", uselist=False
    )
    logs: Mapped[list["LinkClickLog"]] = relationship(
        "LinkClickLog", back_populates="link"
    )


# ===== From main.py =====
app = fastapi.FastAPI(root_path="/api")


app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Adjust this in production to specific domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


def get_hash(str: str):
    return hashlib.md5(str.encode()).hexdigest()


def random_phrase(n_chars):
    phrase = ""
    string = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"
    for _ in range(n_chars):
        phrase += random.choice(string)  # Pick a random letter
    return phrase


@app.post("/url/create", response_model=LinkResponse | ErrorResponse)
async def create_url(
    link: LinkCreate,
    sql_db: AsyncSession = fastapi.Depends(get_async_session),
):
    long_url = link.long_url
    custom_name = link.name.strip() if link.name else None

    hashed_long_url = get_hash(
        str(time.time()) + long_url.encoded_string() + random_phrase(20)
    )
    hashed_string = hashed_long_url[:8]

    sql_db_link = await sql_db.execute(
        select(Link).where(Link.id == (custom_name if custom_name else hashed_string))
    )
    existing_link = sql_db_link.scalars().one_or_none()

    if custom_name and existing_link:
        return {
            "error": "BAD_REQUEST",
            "reason": "Name already occupied, try a different name",
        }
    elif existing_link:  # this is quite rare, but still can happen.. so instead of generating a new hash, we just extend the hash.
        hashed_string = hashed_long_url[: random.randint(9, 12)]

    url_id = custom_name if custom_name else hashed_string

    new_link = Link(id=url_id, long_url=str(long_url))

    new_metadata = LinkMetadata(
        link_id=url_id,
        name=custom_name if custom_name else "",
        long_url=str(long_url),
        clicks=0,
        last_ip=None,
    )

    sql_db.add(new_link)
    sql_db.add(new_metadata)
    await sql_db.commit()
    await sql_db.refresh(new_link)
    await sql_db.refresh(new_metadata)

    # return the Link
    return LinkResponse(
        shortened_url=f"/{new_link.id}",
        long_url=AnyHttpUrl(new_link.long_url),
        metadata=LinkMetadataResponse(
            custom_name=new_metadata.name if new_metadata.name != "" else None,
            clicks=new_metadata.clicks,
            last_ip=new_metadata.last_ip,
        ),
    )


@app.get("/url/{short_url_id}/metadata", response_model=LinkResponse)
async def get_shortened_url_metadata(
    short_url_id: str, sql_db: AsyncSession = fastapi.Depends(get_async_session)
):
    link = (
        (await sql_db.execute(select(Link).where(Link.id == short_url_id)))
        .scalars()
        .one_or_none()
    )

    if not link:
        return {"error": "NOT_FOUND", "message": "The requested URL was not found"}

    metadata = (
        (
            await sql_db.execute(
                select(LinkMetadata).where(LinkMetadata.link_id == short_url_id)
            )
        )
        .scalars()
        .one_or_none()
    )

    if not metadata:
        raise AttributeError("Metadata entry not found for the given link ID")

    return LinkResponse(
        shortened_url=link.id,
        long_url=AnyHttpUrl(link.long_url),
        metadata=LinkMetadataResponse(
            custom_name=metadata.name if metadata.name != "" else None,
            clicks=metadata.clicks,
            last_ip=metadata.last_ip,
        ),
    )


@app.get("/url/{url}/redirect", response_model=LinkRedirectResponse | ErrorResponse)
async def redirect_url(
    url: str,
    req: fastapi.Request,
    sql_db: AsyncSession = fastapi.Depends(get_async_session),
):
    req_client = req.client
    ipaddr = None
    if req_client:
        ipaddr = req_client.host

    link = (
        (await sql_db.execute(select(Link).where(Link.id == url)))
        .scalars()
        .one_or_none()
    )

    if not link:
        return {
            "error": "NOT_FOUND",
            "message": "The requested URL was not found",
            "redirect_to": "/404",
        }

    # update click log
    new_log = LinkClickLog(
        link_id=url,
        click_ip=ipaddr,
        timestamp=datetime.now(),
        user_agent=req.headers.get("user-agent", "unknown"),
    )

    # update the metadata clicks count
    metadata = await sql_db.execute(
        update(LinkMetadata)
        .values(clicks=LinkMetadata.clicks + 1, last_ip=ipaddr)
        .where(LinkMetadata.link_id == url)
    )
    if not metadata:
        raise AttributeError("Metadata entry not found for the given link ID")

    sql_db.add(new_log)
    await sql_db.commit()
    await sql_db.refresh(new_log)

    return {"message": "Redirecting...", "long_url": link.long_url}


@app.post("/alias/suggest", response_model=LinkAliasSuggestionResponse | ErrorResponse)
async def suggest_alias(
    long_url: str,
    count: int = 3,
    sql_db: AsyncSession = fastapi.Depends(get_async_session),
):
    if count > 10:
        return {
            "error": "BAD_REQUEST",
            "reason": "Count must be less than or equal to 10",
        }

    time_taken = time.time()
    # TODO: Integrate with AI as soon as possible
    aliases = set()

    while len(aliases) < count:
        need = count - len(aliases)
        batch = {random_phrase(8) for _ in range(need * 2)}
        existing = (
            await sql_db.execute(select(Link.id).where(Link.id.in_(batch)))
        ).scalars()
        batch -= set(existing)  # remove conflicts already in DB
        aliases.update(batch)

    time_taken = time.time() - time_taken

    return {
        "suggested_aliases": list(aliases)[:count],  # return only the requested count
        "time_taken": time_taken,
    }


@app.get("/alias/check", response_model=LinkAliasAvailabilityResponse | ErrorResponse)
async def check_alias_availability(
    alias: str, sql_db: AsyncSession = fastapi.Depends(get_async_session)
):
    if len(alias) < 5 or len(alias) > 32:
        return {
            "error": "BAD_REQUEST",
            "reason": "Alias length must be between 3 and 32 characters",
            "is_available": False,
            "alias": alias,
        }
    existing = (
        (await sql_db.execute(select(Link.id).where(Link.id == alias)))
        .scalars()
        .one_or_none()
    )

    if existing:
        return {
            "is_available": False,
            "alias": alias,
            "message": "Alias is already taken",
        }
    else:
        return {
            "is_available": True,
            "alias": alias,
            "message": "Alias is available",
        }


@app.get("/url/check", response_model=LinkURLExistenceResponse | ErrorResponse)
async def check_url_existence(
    url: str,
):
    # do a HEAD request to see if the URL exists
    import httpx

    try:
        resp = httpx.head(url, timeout=5.0)
        if resp.status_code >= 400:
            return {
                "error": "NOT_FOUND",
                "message": "The provided URL does not exist or is unreachable",
            }
        else:
            return {
                "exists": True,
                "long_url": url,
                "message": "The provided URL exists and is reachable",
            }
    except httpx.RequestError:
        return {
            "error": "NOT_FOUND",
            "message": "The provided URL does not exist or is unreachable",
        }


@app.get("/404", response_model=ErrorResponse)
async def not_found():
    return {"error": "NOT_FOUND", "message": "The requested URL was not found"}


@app.get("/health")
async def health_check():
    return {"status": "ok", "message": "The server is running fine"}
